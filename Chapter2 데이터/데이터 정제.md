# 결측치(missing value) 정제
결측치는 누락된 값, 비어 있는 값을 의미. 결측치가 있으면 함수가 적용되지 않거나 분석 결과가 왜곡되는 문제 발생.
실제 데이터를 분석할 때는 결측치가 있는지 확인해 제거하는 정제 과정을 거친 다음 분석.
## 결측치 만들기
결측치를 만드려면 NumPy 패키지의 np.nan을 입력. 파이썬에서는 결측치를 NaN으로 표시.
```
import pandas as pd
import numpy as np

df = pd.DataFrame({'sex': ['M', 'F', np.nan, 'M', 'F'], 'score': [5, 4, 3, 4, np.nan]})
df
df['score'] + 1
```
## 결측치 확인하기
pd.isna()를 이용하면 데이터에 결측치가 들어 있는지 확인 가능. pd.isna()에 df를 입력하면 결측치는 True, 결측치가 아닌 값은 False로 표시해 데이터 출력.
출력 결과를 보면 sex의 3행과 score의 5행이 결측치라는 것을 알 수 있음. pd.isna()에 sum()을 적용하면 데이터에 결측치가 총 몇 개 있는지 출력.
```
pd.isna(df)  # 결측치 확인
pd.isna(df).sum()  # 결측치 빈도 확인
```
## 결측치 제거하기
* 결측치 있는 행 제거
df.dropna()를 이용하면 결측치가 있는 행을 제거 가능. subset에 []를 이용해 변수명을 입력하면 됨.
```
df.dropna(subset = ['score'])  # score 결측치 제거
df_nomiss = df.dropna(subset = ['score'])  # score 결측치 제거된 데이터 만들기
df_nomiss['score'] + 1    # score로 연산
```
* 여러 변수에 결측치 없는 데이터 추출
```
df_nomiss = df.dropna(subset = ['score', 'sex'])  # score, sex 결측치 제거
df_nomiss
```
* 결측치가 하나라도 있으면 제거
df.dropna()에 아무 변수도 지정하지 않으면 모든 변수에 결측치가 없는 행만 남김.
```
df_nomiss2 = df.dropna()  # 모든 변수에 결측치 없는 데이터 추출
df_nomiss2
```
결측치가 하나라도 있으면 모두 제거되므로 분석에 필요한 행까지 손실된다는 단점이 있음.
분석에 사용할 변수를 직접 지정해 결측치를 제거하는 방법을 권함.
> pd.mean(), pd.sum()과 같은 수치 연산 함수는 결측치가 있으면 자동으로 제거하고 연산. groupby(), agg()도 결측치를 제거하고 연산.  
> 편리하지만 결측치가 있는지 모르는 채로 데이터를 다루게 된다는 위험 존재.

## 결측치 대체하기
데이터가 작고 결측치가 많을 때는 결측치를 제거하면 너무 많은 데이터가 손실됨. 다른 값을 채워 넣는 방법을 결측치 대체법(imputation)이라고 함.
결측치를 다른 값으로 대체하면 데이터가 손실되어 분석 결과가 왜곡되는 문제 보완 가능.
평균값이나 최빈값 같은 대표값을 구해 모든 결측치를 하나의 값으로 일괄 대체하는 방법과 통계 분석 기법으로 결측치의 예측값을 추정해 대체하는 방법 등이 있음.
* 평균값으로 결측치 대체
```
exam = pd.read_csv('exam.csv')    # 데이터 불러오기
exam.loc[[2, 7, 14], ['math']] = np.nan  # 2, 7, 14행의 math에 NaN 할당. df.loc[]는 데이터의 위치를 지칭하는 역할. [,]에서 쉼표 왼쪽은 행 위치, 쉼표 오른쪽은 열 위치를 의미.
exam['math'].mean()
exam['math'] = exam['math'].fillna(55)  # math가 NaN이면 55로 대체
exam    # 출력
exam['math'].isna().sum()  # 결측치 빈도 확인
```

# 이상치(anomaly) 정제
정상 범위에서 크게 벗어난 값을 이상치라고 함. 데이터 수집 과정에서 오류 발생 가능. 따라서 실제 데이터에 대부분 이상치 존재.
## 존재할 수 없는 이상치 제거
논리적으로 존재할 수 없는 값이 데이터에 들어 있을 때가 있음. 예, 남자는 1, 여자는 2인데 성별 변수에 3이라는 값등.
```
df = pd.DataFrame({'sex': [1, 2, 1, 3, 2, 1], 'score': [5, 4, 3, 4, 2, 6]})  # score는 1~5까지 가능하다는 설정.
```
### 이상치 확인
df.value_counts()를 이용해 빈도표를 만들면 확인 가능.
```
df['sex'].value_counts().sort_index()
df['score'].value_counts().sort_index()
```
> df.value_counts()에 sort_index()를 적용하면 빈도 기준으로 내림차순 정렬하지 않고 변수의 값 순서로 정렬.
### 결측 처리
이상치를 결측치로 바꾸기. np.where()를 이용해 이상치일 경우 NaN을 부여. sex가 3이면 NaN을 부여, 3이 아니면 원래 가지고 있던 값을 부여.
```
# sex가 3이면 NaN 부여
df['sex'] = np.where(df['sex'] == 3, np.nan, df['sex'])
df
# score가 5보다 크면 NaN 부여
df['score'] = np.where(df['score'] > 5, np.nan, df['score'])
df
df.dropna(subset = ['sex', 'score']) \  # sex, score 결측치 제거
  .groupby('sex') \    # sex별 분리
  .agg(mean_score = ('score', 'mena'))  # score 평균 구하기
```
#### np.where()는 문자와 NaN을 함께 반환 불가
np.where()는 반환하는 값 중에 문자가 있으면 np.nan을 지정하더라도 결측치 NaN이 아니라 문자 'nan'을 반환.
```
df = pd.DataFrame({'x1': [1, 1, 2, 2]})
df['x2'] = np.where(df['x1'] == 1, 'a', np.nan)  # 조건에 맞지 않으면 문자 부여
df
df.isna()
# 결측치로 만들 값에 문자 부여
df['x2'] = np.where(df['x1'] == 1, 'a', 'etc')
# 'etc'를 NaN으로 바꾸기
df['x2'] = df['x2'].replace('etc', np.nan)
df
df.isna()
```

## 극단적인 이상치 제거
논리적으로 존재할 수 있지만 극단적으로 크거나 작은 값을 극단치(outlier)라고 함. (예: 몸무게 변수 200kg이상 값). 극단치를 제거하려면 먼저 어디까지를 정상 범위로 볼 것인지 정해야 함.
가장 쉬운 방법은 논리적으로 판단해 정하는 것. 두 번째 방법은 통계적인 기준을 이용하는 것. 상하위 0.3% 또는 +-3 표준편차에 해당할 만큼 극단적으로 크거나 작으면 극단치로 간주.

### 상자 그림으로 극단치 기준 정하기
상자 그림(box plot)을 이용해 중심에서 크게 벗어난 값을 극단치로 간주하는 방법. 데이터의 분포를 직사각형의 상자 모양으로 표현한 그래프.
상자 그림은 중심에서 멀리 떨어진 값을 점으로 표현. 상자 그림을 이용해 극단치 기준을 구하는 방법.
1. 상자 그림 살펴보기
seaborn 패키지의 boxplot()을 이용.
```
mpg = pd.read_csv('mpg.csv')

import seaborn as sns
sns.boxplot(data = mpg, y = 'hwy')
```
상자 그림은 값을 크기순으로 나열해 4등분 했을 때 위치하는 값인 '사분위수'를 이용해 만듬.
|상자 그림|값|설명|
|:--|:--|:--|
|상자 아래 세로선|아랫수염|하위 0~25% 내에 해당하는 값|
|상자 밑면|1사분위수(Q1)|하위 25% 위치 값|
|상자 내 굵은 선|2사분위수(Q2)|하위 50% 위치 값(중앙값)|
|상자 윗면|3사분위수(Q3)|하위 75% 위치 값|
|상자 위 세로선|윗수염|하위 75%~100% 내에 해당하는 값|
|상자 밖 가로선|극단치 경계|Q1, Q3 밖 1.5 IQR 내 최대값|
|상자 밖 점 표식|극단치|Q1, Q3 밖 1.5 IQR을 벗어난 값|

'IQR(사분위 범위)'은 1사분위수와 3사분위수의 거리를 뜻함. '1.5 IQR'은 IQR의 1.5배를 뜻함.  
위에서 출력한 상자 그림을 보면 hwy 값을 크기순으로 나열했을 때 하위 25% 지점에 18, 중앙에 24, 75% 지점에 27이 위치함.
직사각형 밖에 있는 아래, 위 가로선을 보면 12~37을 벗어난 값이 극단치로 분류됨. 가로선 밖에 표현된 점 표식은 극단치를 의미.

2. 극단치 기준값 구하기
(1) 1사분위수, 3사분위수 구하기
df.quantile()을 이용하면 분위수(quantile)를 구할 수 있음.
```
pct25 = mpg['hwy'].quantile(.25)
pct25        # 하위 25%에 해당하는 1사분위수.
pct75 = mpg['hwy'].quantile(.75)
pct75        # 하위 75%에 해당하는 3사분위수.
```
(2) IQR 구하기
pct25와 pct75를 이용해 1사분위수와 3사분위수의 거리를 나타낸 IQR(inter quartile range, 사분위 범위)를 구함.
```
iqr = pct75 - pct25
iqr
```
(3) 하한, 상한 구하기
극단치의 경계가 됨.
* 하한: 1사분위수보다 'IQR의 1.5배'만큼 더 작은 값
* 상한: 3사분위수보다 'IQR의 1.5배'만큼 더 큰 값

```
pct25 - 1.5 * iqr  # 하한
pct75 + 1.5 * iqr  # 상한
```

3. 극단치를 결측 처리하기
np.where()를 이용해 기준값을 벗어나면 결측 처리. np.where()에 여러 조건을 입력할 때는 각 조건을 괄호로 감싸야 함.
```
# 4.5 ~ 40.5 벗어나면 NaN 부여
mpg['hwy'] = np.where((mpg['hwy'] < 4.5) | (mpg['hwy'] > 40.5), np.nan, mpg['hwy'])
# 결측치 빈도 확인
mpg['hwy'].isna().sum()
```

4. 결측치 제거하고 분석하기
극단치를 결측 처리했으니 분석하기 전에 결측치 제거. drv(구동 방식)에 따라 hwy(고속도로 연비) 평균이 어떻게 다른지 알아보기.
```
mpg.dropna(subset = ['hwy']) \    # hwy 결측치 제거
   .groupby('drv')  \             # drv별 분리
   .agg(mean_hwy = ('hwy', 'mean'))  # hwy 평균 구하기
```
